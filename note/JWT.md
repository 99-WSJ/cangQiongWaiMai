#### 什么是 IWT?
ISON Web Token，通过数字签名的方式，以JSON 对象为载体，在不同的服务终端之间安全的传输信息。

#### JWT有什么用?
JWT最常见的场景就是授权认证，一旦用户登录，，后续每个请求都将包含JWT，系统在每次处理用户请求的之前，都要先进行JWT安全校验，通过之后再进行处理。
JWT 的组成由3部分组成，用 . 拼接
eyJhbGcioiJIUzI1NiIsInR5cCI6Ikpxvc9.eyJ1c2vybmFtzsI6IlRvbsIsInJvbGuioi]hzGlpbiIsInN1YiI6ImFkbW1uLXR1c3QiLCJ1eHAi0jE2MjMyMjM2NzUSImpOaSI6ImQ2MTJjZjCxLWI5ZmUtNGMWNy04MzQWLTVi0WViZmMyNEXNyJ9.FOS9Y7rYNdc2AoidnSPrgg2XTYePu0yGz598h2qtabE



这三部分分别是


* Header（第一部分）

  { 

  ​	type':'JWT'',

  ​	alg':'HS256'

  }

* Payload (第二部分)

​		{	


​					"sub" :1234567890'

​					"name": 'john'
​					"admin":true

​		}

* Signature（第三部分）HS256算法，HS256 使用 SHA-256 作为哈希函数

  ```java
  var encodedstring=base64urlEncode(header)+'.'+
  	base64UrlEncode(payload);
  var signature =HMACSHA256(encodedstring，'secret');
  // signature是用前两部分生成的加密签名
  ```

#### B站评论

```txt
我来说一下jwt吧，因为实际用过所以就更清除内在原理，实际上就是 jwt有三部分嘛，第一部分是header头部分，主要用来转哈希的吧，第二部分是payload数据部分，第三部分是signature签名部分，然后整个流程是：客户端登录成功后，服务端为了后面你来服务端请求数据不用再把账号密码带过来验证一遍，就整出来一个叫令牌的东西说“以后你拿这个令牌来和我拿数据”，令牌上写着你的名字和ID和过期时间等等（这里放别的信息也可以，别放密码就行，这里就是payload部分），到这里想想大家已经看出不对了，就是我不能直接把这个没加密的令牌发给你客户端吧，不然谁都能伪造出这个令牌来和我服务端拿数据（比如我令牌上写着charry，那客户端b生成一个charry的令牌发给服务端也能随便拿数据了），所以服务端就和程序员说：“你这个程序员别那么懒，给个密钥加密一下，保证数据安全”，此时程序员就给了个密钥，比如我叫charry，那我就用“charry”作为密钥，来设置这个生成签名signature的密钥，重点来了，这个signature是用这个密钥加密（第二部分“payload” 和 第一部分“header”）生成的，那么只要客户端不知道服务端设置的密钥（charry），那就不可能伪造签名来获取数据，因为只要我改了payload里的任意东西，或者第一部分header的东西，那么在发给服务端后，服务端会进行header+payload再生成一次signature，只要这个signature和服务端生成的signature不一样，那就不通过，又有人要说那我直接改signature，那也不行的，除非你能猜出密钥，所以这种模式就实现了安全的分布式（客户端）存储登录信息，不知道讲清楚了没哈哈哈，有什么不对大家也可以指出来

前端发去服务端时，用服务端设置的密钥+前端payload和header再生成一次signature，和原来生成的signature做比较，这个比较就是验证了，通过就可以拿数据了

这里原来的signature，保存在客户端的localstorage中，发送网络请求时拿出来设置到请求头里

防止不了 客户端本地存储的jwt 被别人拿去直接用，只能防止在传输过程中被别人篡改，因为一篡改服务端通过密钥重新对传过来的jwt的payload和header生成签名就会发现这个签名和传过来的签名不是一样的

jwt使用的密钥不是用来加密的哦，而是用来签名的，签名是为了保证数据不被篡改，它只是对json串编码，减小字节数，方便传输

jwt是不加密的哦，看起来像密文其实是base64编码，任何人都可以base64解码的

不是对称加密的哦，密钥是用来签名用的，同时也是通过验证签名来实现token验证，不是对称加密的那种加解密哦

由于移动互联的发展，手机应用不像浏览器自带cookie，这推动了一种更加安全的方案token。session之于cookie区别在于那串字符的加密。token区别除了加密更侧重的则是客户端与服务端的鉴权，结合对称与非对称加密，使用时间戳等等。

jwt不是加密，只是对json串编码，减小字节数(不绝对)，方便传输。token的安全在于鉴权验证，一些复杂的token机制中，一个token令牌可以包含地理位置信息，网络信息，客户端属性，包括浏览器指纹。即便token泄漏，其他人拿着这个token也难以请求成功。token都是有时效的，有时采用双token，一个用于登录访问，时效可能就一两天甚至几小时，一个用于获取新的token。总之各种技术尽可能保证安全。
```

#### CSRF攻击

* 跨站请求伪造是一种网络攻击，攻击者通过伪造受信任用户的请求，利用用户在某个网站的已认证身份，向该网站发送未经授权的请求，从而执行某些操作。

* ```java
  1、用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
  
  2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
  
  3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
  
  4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
  
  5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行
  
  ```

* 解决方式

  1、只使用JSON API

  * 使用JavaScript发起AJAX请求是限制跨域的，并不能通过简单的 表单来发送JSON，所以，通过只接收JSON可以很大可能避免CSRF攻击。

  2、验证HTTP Referer字段

  * 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP  请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站。而如果黑客要对银行网站实施 CSRF  攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。

    因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example  开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

  3、在请求地址中添加takon验证

  * 生成Token：在生成表单或敏感请求时，服务器生成一个唯一的、难以预测的Token，并将其嵌入到表单或请求中。
  * 验证Token：服务器接收到请求后，验证Token的有效性。如果Token无效，则拒绝请求。

#### XSS

* “跨站脚本攻击”，是一种安全漏洞，攻击者通过注入恶意脚本到受信任的网页中，从而在其他用户浏览该网页时执行恶意脚本。XSS攻击可以用于窃取用户的会话、篡改网页内容、传播恶意软件等。
* 根据注入和执行方式的不同，XSS主要分为三种类型：反射型、存储型和DOM型。

#### 对称加密算法

对称加密是一种加密方法，在这种方法中，加密和解密使用相同的密钥。由于加密和解密使用相同的密钥，因此必须确保密钥的安全性。

* AES、DES、RC4、Rabbit、TripleDes、Blowfish
* 优点：加密高效
* 缺点：需要保证密钥传递信道安全，存在密钥泄露风险

#### 非对称加密

非对称加密是一种加密方法，使用一对密钥，其中一个用于加密（公钥），另一个用于解密（私钥）。公钥是公开的，可以自由分发，而私钥必须保密。

* RSA、ECC、DSA、Diffie-Hellman

* 优点：不需要传递私钥，更安全
* 缺点：计算量较大，性能较差，传递步骤复杂



#### MD5

MD5（Message Digest Algorithm 5）是一种广泛使用的哈希函数，能够生成一个128位（16字节）的哈希值（散列值），通常用作数据完整性校验。

**特性**：

- **输出长度**：128位（16字节）
- **不可逆**：无法从哈希值逆推出原始数据。
- **快速计算**：适合处理大数据量。
- **易受攻击**：由于存在碰撞漏洞（即不同的输入可以生成相同的哈希值），MD5不再被认为是安全的哈希函数，已被更安全的算法如SHA-256取代。

用途: **数据完整性校验**：用于验证数据在传输或存储过程中是否被篡改